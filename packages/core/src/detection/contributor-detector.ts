import { LevenshteinMatcher } from './levenshtein-matcher.js';
import type { GitHunk } from '../models/git-types.js';
import type { SessionSource } from '../models/session-source.js';
import { SIMILARITY_CONFIG, type ContributorType } from '../constants.js';

/**
 * Agent record - represents code generated by an AI Agent
 */
export interface AgentRecord {
  /** Unique identifier */
  id: string;

  /** Session source information */
  sessionSource: SessionSource;

  /** File path where the code was generated */
  filePath: string;

  /** The generated code content */
  content: string;

  /** Lines added by the Agent */
  addedLines: string[];

  /** Timestamp when the code was generated */
  timestamp: number;
}

/**
 * Contributor detection result
 */
export interface ContributorResult {
  /** Hunk ID */
  hunkId: string;

  /** Detected contributor type */
  contributor: ContributorType;

  /** Similarity score (0-1) */
  similarity: number;

  /** Matched Agent record (if any) */
  matchedRecord?: AgentRecord;

  /** Confidence level (0-1) */
  confidence: number;
}

/**
 * Contributor Detector - Determines code contributor (AI vs Human)
 *
 * Uses Hunk-level similarity matching with Levenshtein algorithm
 * to determine if code was generated by an AI Agent.
 */
export class ContributorDetector {
  private readonly matcher: LevenshteinMatcher;
  private readonly thresholdPureAi: number;
  private readonly thresholdAiModified: number;

  constructor(options?: { thresholdPureAi?: number; thresholdAiModified?: number }) {
    this.matcher = new LevenshteinMatcher();
    this.thresholdPureAi = options?.thresholdPureAi ?? SIMILARITY_CONFIG.THRESHOLD_PURE_AI;
    this.thresholdAiModified = options?.thresholdAiModified ?? SIMILARITY_CONFIG.THRESHOLD_AI_MODIFIED;
  }

  /**
   * Detect contributor for a single hunk
   */
  detect(hunk: GitHunk, agentRecords: AgentRecord[]): ContributorResult {
    // Filter records by file path
    const relevantRecords = agentRecords.filter((record) => record.filePath === hunk.filePath);

    if (relevantRecords.length === 0) {
      return this.createHumanResult(hunk.id);
    }

    // Get the added lines from the hunk as the comparison target
    const hunkContent = hunk.addedLines.join('\n');

    if (hunkContent.trim().length === 0) {
      return this.createHumanResult(hunk.id);
    }

    // Find best matching record
    let bestMatch: AgentRecord | undefined;
    let bestSimilarity = 0;

    for (const record of relevantRecords) {
      const recordContent = record.addedLines.join('\n');
      const similarity = this.matcher.calculate(hunkContent, recordContent);

      if (similarity > bestSimilarity) {
        bestSimilarity = similarity;
        bestMatch = record;
      }
    }

    // Determine contributor type based on thresholds
    return this.determineContributor(hunk.id, bestSimilarity, bestMatch);
  }

  /**
   * Batch detect contributors for multiple hunks
   */
  batchDetect(hunks: GitHunk[], agentRecords: AgentRecord[]): ContributorResult[] {
    return hunks.map((hunk) => this.detect(hunk, agentRecords));
  }

  /**
   * Detect contributors for all hunks in a file diff
   */
  detectForFile(
    filePath: string,
    hunks: GitHunk[],
    agentRecords: AgentRecord[]
  ): Map<string, ContributorResult> {
    const results = new Map<string, ContributorResult>();

    // Filter records for this file
    const fileRecords = agentRecords.filter((r) => r.filePath === filePath);

    for (const hunk of hunks) {
      const result = this.detect(hunk, fileRecords);
      results.set(hunk.id, result);
    }

    return results;
  }

  /**
   * Get summary statistics for a batch of results
   */
  getSummary(results: ContributorResult[]): ContributorSummary {
    const summary: ContributorSummary = {
      total: results.length,
      ai: 0,
      aiModified: 0,
      human: 0,
      averageSimilarity: 0,
      averageConfidence: 0,
    };

    let totalSimilarity = 0;
    let totalConfidence = 0;

    for (const result of results) {
      switch (result.contributor) {
        case 'ai':
          summary.ai++;
          break;
        case 'ai_modified':
          summary.aiModified++;
          break;
        case 'human':
          summary.human++;
          break;
      }

      totalSimilarity += result.similarity;
      totalConfidence += result.confidence;
    }

    if (results.length > 0) {
      summary.averageSimilarity = totalSimilarity / results.length;
      summary.averageConfidence = totalConfidence / results.length;
    }

    return summary;
  }

  // ==================== Private Methods ====================

  private determineContributor(
    hunkId: string,
    similarity: number,
    matchedRecord?: AgentRecord
  ): ContributorResult {
    if (similarity >= this.thresholdPureAi) {
      return {
        hunkId,
        contributor: 'ai',
        similarity,
        matchedRecord,
        confidence: this.calculateConfidence(similarity, 'ai'),
      };
    }

    if (similarity >= this.thresholdAiModified) {
      return {
        hunkId,
        contributor: 'ai_modified',
        similarity,
        matchedRecord,
        confidence: this.calculateConfidence(similarity, 'ai_modified'),
      };
    }

    return this.createHumanResult(hunkId, similarity, matchedRecord);
  }

  private createHumanResult(
    hunkId: string,
    similarity = 0,
    matchedRecord?: AgentRecord
  ): ContributorResult {
    return {
      hunkId,
      contributor: 'human',
      similarity,
      matchedRecord,
      confidence: this.calculateConfidence(similarity, 'human'),
    };
  }

  private calculateConfidence(similarity: number, contributor: ContributorType): number {
    switch (contributor) {
      case 'ai':
        // Higher similarity = higher confidence for AI
        return Math.min(1, (similarity - this.thresholdPureAi) / (1 - this.thresholdPureAi) * 0.5 + 0.5);

      case 'ai_modified': {
        // Middle range has lower confidence
        const range = this.thresholdPureAi - this.thresholdAiModified;
        const position = (similarity - this.thresholdAiModified) / range;
        return 0.5 + position * 0.3;
      }

      case 'human':
        // Lower similarity = higher confidence for human
        if (similarity === 0) {
          return 1;
        }
        return Math.max(0.3, 1 - similarity / this.thresholdAiModified);
    }
  }
}

/**
 * Summary statistics for contributor detection
 */
export interface ContributorSummary {
  total: number;
  ai: number;
  aiModified: number;
  human: number;
  averageSimilarity: number;
  averageConfidence: number;
}
