import { LevenshteinMatcher } from './levenshtein-matcher.js';
import type { GitHunk } from '../models/git-types.js';
import type { SessionSource } from '../models/session-source.js';
import { SIMILARITY_CONFIG, FILTERING_CONFIG, type ContributorType } from '../constants.js';
import { PerformanceTracker } from '../performance/performance-tracker.js';

/**
 * Agent record - represents code generated by an AI Agent
 */
export interface AgentRecord {
  /** Unique identifier */
  id: string;

  /** Session source information */
  sessionSource: SessionSource;

  /** File path where the code was generated */
  filePath: string;

  /** The generated code content */
  content: string;

  /** Lines added by the Agent */
  addedLines: string[];

  /** Timestamp when the code was generated */
  timestamp: number;
}

/**
 * Configuration options for ContributorDetector
 */
export interface DetectorConfig {
  /** Threshold for pure AI detection (default: 0.9) */
  thresholdPureAi?: number;
  /** Threshold for AI-modified detection (default: 0.7) */
  thresholdAiModified?: number;
  /** Time window for filtering records (in days, default: 3) */
  timeWindowDays?: number;
  /** Content length tolerance for filtering (default: 0.5 = 50%) */
  lengthTolerance?: number;
  /** Performance threshold in ms (default: 500) */
  performanceThreshold?: number;
}

/**
 * Contributor detection result
 */
export interface ContributorResult {
  /** Hunk ID */
  hunkId: string;

  /** Detected contributor type */
  contributor: ContributorType;

  /** Similarity score (0-1) */
  similarity: number;

  /** Matched Agent record (if any) */
  matchedRecord?: AgentRecord;

  /** Confidence level (0-1) */
  confidence: number;

  /** Performance metrics (if tracking enabled) */
  performanceMetrics?: ReturnType<PerformanceTracker['finalize']>;
}

/**
 * Contributor Detector - Determines code contributor (AI vs Human)
 *
 * Uses Hunk-level similarity matching with Levenshtein algorithm
 * to determine if code was generated by an AI Agent.
 * 
 * Implements a 4-level filtering strategy for performance optimization:
 * 1. File path filtering - Only consider records for the same file
 * 2. Time window filtering - Only consider records within the configured time window
 * 3. Content length filtering - Filter out records with significantly different content length
 * 4. Levenshtein similarity - Calculate actual similarity for remaining candidates
 */
export class ContributorDetector {
  private readonly matcher: LevenshteinMatcher;
  private readonly thresholdPureAi: number;
  private readonly thresholdAiModified: number;
  private readonly timeWindowDays: number;
  private readonly lengthTolerance: number;
  private readonly performanceThreshold: number;

  constructor(options?: DetectorConfig) {
    this.matcher = new LevenshteinMatcher();
    this.thresholdPureAi = options?.thresholdPureAi ?? SIMILARITY_CONFIG.THRESHOLD_PURE_AI;
    this.thresholdAiModified = options?.thresholdAiModified ?? SIMILARITY_CONFIG.THRESHOLD_AI_MODIFIED;
    this.timeWindowDays = options?.timeWindowDays ?? FILTERING_CONFIG.DEFAULT_TIME_WINDOW_DAYS;
    this.lengthTolerance = options?.lengthTolerance ?? FILTERING_CONFIG.DEFAULT_LENGTH_TOLERANCE;
    this.performanceThreshold = options?.performanceThreshold ?? 500;
  }

  /**
   * Detect contributor for a single hunk with optional performance tracking
   * 
   * Implements 4-level filtering:
   * 1. File path filtering
   * 2. Time window filtering
   * 3. Content length filtering
   * 4. Levenshtein similarity calculation
   */
  detect(
    hunk: GitHunk, 
    agentRecords: AgentRecord[],
    options?: { enableTracking?: boolean }
  ): ContributorResult {
    const tracker = options?.enableTracking 
      ? new PerformanceTracker(this.performanceThreshold)
      : undefined;
    
    // Set context for tracking
    tracker?.setContext(hunk.filePath, hunk.addedLines.length);

    // Get the added lines from the hunk as the comparison target
    const hunkContent = hunk.addedLines.join('\n');
    const hunkLength = hunkContent.length;

    if (hunkContent.trim().length === 0) {
      return this.createHumanResult(hunk.id, 0, undefined, tracker?.finalize());
    }

    // ===== Level 1: File path filtering =====
    let candidates = agentRecords.filter((record) => record.filePath === hunk.filePath);
    tracker?.recordFilterStep('filePath', candidates.length);

    if (candidates.length === 0) {
      return this.createHumanResult(hunk.id, 0, undefined, tracker?.finalize());
    }

    // ===== Level 2: Time window filtering =====
    const timeWindowMs = this.timeWindowDays * 24 * 60 * 60 * 1000;
    const cutoffTime = Date.now() - timeWindowMs;
    candidates = candidates.filter((record) => record.timestamp >= cutoffTime);
    tracker?.recordFilterStep('timeWindow', candidates.length);

    if (candidates.length === 0) {
      return this.createHumanResult(hunk.id, 0, undefined, tracker?.finalize());
    }

    // ===== Level 3: Content length filtering =====
    candidates = candidates.filter((record) => {
      const recordContent = record.addedLines.join('\n');
      const recordLength = recordContent.length;
      
      // Skip if either is empty
      if (hunkLength === 0 || recordLength === 0) {
        return hunkLength === 0 && recordLength === 0;
      }
      
      const ratio = Math.max(hunkLength, recordLength) / Math.min(hunkLength, recordLength);
      return ratio <= (1 + this.lengthTolerance);
    });
    tracker?.recordFilterStep('length', candidates.length);

    if (candidates.length === 0) {
      return this.createHumanResult(hunk.id, 0, undefined, tracker?.finalize());
    }

    // ===== Level 4: Levenshtein similarity calculation =====
    let bestMatch: AgentRecord | undefined;
    let bestSimilarity = 0;

    for (const record of candidates) {
      const recordContent = record.addedLines.join('\n');
      const similarity = this.matcher.calculate(hunkContent, recordContent, tracker);

      if (similarity > bestSimilarity) {
        bestSimilarity = similarity;
        bestMatch = record;
      }
    }

    // Record result and finalize tracking
    tracker?.recordResult(bestSimilarity, bestSimilarity >= this.thresholdAiModified);
    const performanceMetrics = tracker?.finalize();

    // Determine contributor type based on thresholds
    return this.determineContributor(hunk.id, bestSimilarity, bestMatch, performanceMetrics);
  }

  /**
   * Batch detect contributors for multiple hunks
   */
  batchDetect(hunks: GitHunk[], agentRecords: AgentRecord[]): ContributorResult[] {
    return hunks.map((hunk) => this.detect(hunk, agentRecords));
  }

  /**
   * Detect contributors for all hunks in a file diff
   */
  detectForFile(
    filePath: string,
    hunks: GitHunk[],
    agentRecords: AgentRecord[]
  ): Map<string, ContributorResult> {
    const results = new Map<string, ContributorResult>();

    // Filter records for this file
    const fileRecords = agentRecords.filter((r) => r.filePath === filePath);

    for (const hunk of hunks) {
      const result = this.detect(hunk, fileRecords);
      results.set(hunk.id, result);
    }

    return results;
  }

  /**
   * Get summary statistics for a batch of results
   */
  getSummary(results: ContributorResult[]): ContributorSummary {
    const summary: ContributorSummary = {
      total: results.length,
      ai: 0,
      aiModified: 0,
      human: 0,
      averageSimilarity: 0,
      averageConfidence: 0,
    };

    let totalSimilarity = 0;
    let totalConfidence = 0;

    for (const result of results) {
      switch (result.contributor) {
        case 'ai':
          summary.ai++;
          break;
        case 'ai_modified':
          summary.aiModified++;
          break;
        case 'human':
          summary.human++;
          break;
      }

      totalSimilarity += result.similarity;
      totalConfidence += result.confidence;
    }

    if (results.length > 0) {
      summary.averageSimilarity = totalSimilarity / results.length;
      summary.averageConfidence = totalConfidence / results.length;
    }

    return summary;
  }

  // ==================== Private Methods ====================

  private determineContributor(
    hunkId: string,
    similarity: number,
    matchedRecord?: AgentRecord,
    performanceMetrics?: ReturnType<PerformanceTracker['finalize']>
  ): ContributorResult {
    if (similarity >= this.thresholdPureAi) {
      return {
        hunkId,
        contributor: 'ai',
        similarity,
        matchedRecord,
        confidence: this.calculateConfidence(similarity, 'ai'),
        performanceMetrics,
      };
    }

    if (similarity >= this.thresholdAiModified) {
      return {
        hunkId,
        contributor: 'ai_modified',
        similarity,
        matchedRecord,
        confidence: this.calculateConfidence(similarity, 'ai_modified'),
        performanceMetrics,
      };
    }

    return this.createHumanResult(hunkId, similarity, matchedRecord, performanceMetrics);
  }

  private createHumanResult(
    hunkId: string,
    similarity = 0,
    matchedRecord?: AgentRecord,
    performanceMetrics?: ReturnType<PerformanceTracker['finalize']>
  ): ContributorResult {
    return {
      hunkId,
      contributor: 'human',
      similarity,
      matchedRecord,
      confidence: this.calculateConfidence(similarity, 'human'),
      performanceMetrics,
    };
  }

  private calculateConfidence(similarity: number, contributor: ContributorType): number {
    switch (contributor) {
      case 'ai':
        // Higher similarity = higher confidence for AI
        return Math.min(1, (similarity - this.thresholdPureAi) / (1 - this.thresholdPureAi) * 0.5 + 0.5);

      case 'ai_modified': {
        // Middle range has lower confidence
        const range = this.thresholdPureAi - this.thresholdAiModified;
        const position = (similarity - this.thresholdAiModified) / range;
        return 0.5 + position * 0.3;
      }

      case 'human':
        // Lower similarity = higher confidence for human
        if (similarity === 0) {
          return 1;
        }
        return Math.max(0.3, 1 - similarity / this.thresholdAiModified);
    }
  }
}

/**
 * Summary statistics for contributor detection
 */
export interface ContributorSummary {
  total: number;
  ai: number;
  aiModified: number;
  human: number;
  averageSimilarity: number;
  averageConfidence: number;
}
